<?xml version="1.0" encoding="utf-8"?>
<!--- 
The game's point of entry.
-->
<mx:Application 
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:ui="ui.*"
	layout="absolute"
  width="800"
  height="600"
  backgroundColor="0x9a8685"
	backgroundGradientAlphas="{[0.0, 0.0]}"
  verticalScrollPolicy="off"
  frameRate="30"
  applicationComplete="init();">

	<mx:Style source="styles/symptom.css" />
	
	<mx:Script>
		<![CDATA[
			import units.*;
			import ui.*;
			import io.InputState;
			import utils.*;
			import utils.LinkedList.*;
			import __AS3__.vec.Vector;
			import mx.controls.Image;
			import mx.controls.Text;
			import mx.controls.Alert;
			import mx.controls.ProgressBar;
			import mx.containers.Canvas;
			import mx.containers.Panel;
			import mx.modules.ModuleManager;
			import mx.managers.PopUpManager;
			import mx.events.ModuleEvent;
			import mx.events.CloseEvent;
			import mx.events.StateChangeEvent;
			import mx.modules.IModuleInfo;
			import mx.effects.Fade;
			import mx.effects.easing.Cubic;
			
			/////////////////////////////////////////////////////////////////////////
			// CONSTANTS
			/////////////////////////////////////////////////////////////////////////
			
			/** Fixed width of a level in pixels. */
			public static const LEVEL_WIDTH:Number = 400;
			/** Minimum height of a level. */
			public static const MIN_LEVEL_HEIGHT:Number = 600;
			/** Maximum height of a level. */
			public static const MAX_LEVEL_HEIGHT:Number = 6000;
			
			/** Amount of simulation steps per second (amount of game loop iterations per second). */
			public static const TICKS_PER_SECOND:int = 30;
			private const DT:Number = 1.0 / TICKS_PER_SECOND;
			
			/** Window of time immediately following cell infection for launching. */
			public static const LAUNCH_TIME_MS:Number = 2000.0;
			
			/** Coefficient of friction. */
			public static const F_DRAG:Number = 0.01;
			/** Coefficient of restitution (amount of bounce after a collision). */
			public static const RESTITUTION:Number = 0.3;
			
			/** The maximum distance from virus to center of end area that will trigger player victory. */
			public static const VICTORY_DISTANCE:Number = 20.0;
			
			/////////////////////////////////////////////////////////////////////////
			// VARIABLES
			/////////////////////////////////////////////////////////////////////////
			
			/** For loading modules. */
			protected var moduleInfo:IModuleInfo;

			/** For uploading files. */
			protected var file:FileReference;
			
			/** The level editor. */
			protected var levelEditor:LevelEditor;
			
			/** Plays sound effects and music. */
			[Bindable]
			protected var soundManager:SoundManager;
			
			/** Timer for the game loop. */
			protected var loopTimer:Timer;
			
			/** Timer for virus launch. */
			protected var launchTimer:Timer;
			
			/** The current level being played. */
			protected var currentLevel:Level;
			
			/** The player-controlled virus. */
			protected var virus:Virus;

			/** The current player input state. */
			protected var input:InputState;

			protected function init():void {
				new FPS(fps); // DEBUG
								
				input = new InputState(this);
				
				soundManager = new SoundManager();
				
				// Set up level loading mechanism.
				file = new FileReference();
				file.addEventListener(Event.SELECT, function():void { file.load(); });
				file.addEventListener(Event.COMPLETE, _loadLevelFile, false, 0, true);
				
				// Set up level editor module.
				moduleInfo = ModuleManager.getModule("LevelEditor.swf");
				moduleInfo.addEventListener(ModuleEvent.READY, _openLevelEditor);

				// Initialize game variables.
				main.setTileImage(background);
				
				virus = new Virus(this);

				loopTimer = new Timer(1000 / TICKS_PER_SECOND);
				loopTimer.addEventListener(TimerEvent.TIMER, theLoop);

				var launchDelay:Number = 20;
				launchTimer = new Timer(launchDelay, LAUNCH_TIME_MS / launchDelay);
				launchTimer.addEventListener(TimerEvent.TIMER, expireLaunch);
				
				// Go to splash screen.
				addEventListener(StateChangeEvent.CURRENT_STATE_CHANGE, stateChanged);
				currentState = "splash";
			}
			
			/** Handles state changes. */
			protected function stateChanged(e:StateChangeEvent = null):void {
				if (currentState == "splash") {
					soundManager.playSplashMusic();
				} else if (currentState == "") {
					soundManager.playGameMusic();
				}
			}
			
			/** Starts a new game to play. */
			protected function play(xmlLevel:XML = null):void {					
				if (xmlLevel == null) {				
					xmlLevel = Level.getLevel(0);
				}
				
				try {
					currentLevel = new Level(xmlLevel);
				} catch (e:Error) {
					Alert.show(e.message, "Symptom > Load level");
					return;
				}
				
				main.removeAllChildren();
				
				main.height = currentLevel.height;
				main.y = height - main.height;
				
				// Virus needs to be first in list for proper collision handling.
				// This is because of how the pair-wise collisions are processed 
				// (a dubious constraint for coding convenience).
				currentLevel.bodies.addFirst(virus);
				
				// Load level data.				
				for each (var ea:EndArea in currentLevel.endAreas) {
					main.addChild(ea);
				}
				
				for (var I:LinkedListIterator = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					main.addChild(I.next().data as Body);
				}
				
				virus.reset();
				virus.x = main.width/2 - virus.width/2;
				virus.y = main.height - virus.height - 5;
				main.addChild(virus);
				
				// Start game.
				currentState = "";
								
				loopTimer.start();
			}
			
			// Opens the level editor.
			private function _openLevelEditor(e:ModuleEvent):void {
				levelEditor = moduleInfo.factory.create() as LevelEditor;
				
				PopUpManager.addPopUp(levelEditor, this, false);
				PopUpManager.centerPopUp(levelEditor);
			}
			
			// Listener to load level data from a pre-selected file. Should not be called directly.
			private function _loadLevelFile(e:Event):void {
				var buffer:ByteArray = file.data;
				
				try {
					var level:XML = XML(buffer.readUTFBytes(buffer.bytesAvailable));
				} catch (e:Error) {
					Alert.show("Selected file has invalid content!", "Symptom > Load custom level");
					return;
				}
				
				play(level);
			}
			
			/** Ends the game. */
			protected function endGame(isWin:Boolean):void {
				loopTimer.stop();
				launchTimer.stop();

				var toSplash:Function = function(e:CloseEvent):void { currentState = "splash"; };
				if (isWin) {						
					Alert.show("You win!", "Symptom", Alert.OK, this, toSplash);
				} else {
					Alert.show("You lost!", "Symptom", Alert.OK, this, toSplash);
				}
			}

			/** Checks launch timer expiration and handles launching. */
			protected function expireLaunch(e:TimerEvent = null):void {
				if (e != null) {
					// Draw launch progress indicator ring.
					var radius:Number = 8;
					var alpha:Number = 1.0 - (launchTimer.currentCount / launchTimer.repeatCount);
					
					virus.graphics.clear();
					virus.graphics.beginFill(0x00aa00);
					virus.graphics.drawCircle(virus.width/2, -radius, radius*alpha);
					
					if (launchTimer.currentCount < launchTimer.repeatCount) {
						return;
					}
				}
				
				soundManager.playRandomLaunch();
				
				virus.graphics.clear();
				virus.toggleArrow(false);
				
				launchTimer.reset();
				
				// Remove infected body from game.
				var i:Body = virus.infected.data as Body;
				currentLevel.bodies.remove(virus.infected);
				i.setStyle("removedEffect", fade);
				main.removeChild(i);
				
				virus.infected = null;
			}
			
			/** The main game loop. */
			protected function theLoop(e:TimerEvent):void {
				// Some variables for reuse.
				var i:int, j:int;
				var b:Body, bi:Body, bj:Body;
				var img:Image;
				var I:LinkedListIterator, J:LinkedListIterator;
				var ni:Node, nj:Node;
				var ea:EndArea;
				
				var virusCenter:Vector2    = virus.getCenter();
				var virusDirection:Vector2 = virus.getDirection();
				var virusSpeed:Number      = virus.v.length();
				
				/////////////////////////////////////////
				// CHECK FOR VICTORY CONDITION
				/////////////////////////////////////////
				
				for each (ea in currentLevel.endAreas) {						
					var eac:Vector2 = new Vector2(ea.x + ea.width/2, ea.y + ea.height/2);
					
					if (virusCenter.subtract(eac).length() < VICTORY_DISTANCE) {
						endGame(true);
					}
				}
				
				/////////////////////////////////////////
				// CLEAR FORCES
				/////////////////////////////////////////

				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.F.zero();
				}
				
				/////////////////////////////////////////
				// ADD FORCES
				/////////////////////////////////////////
				
				// VIRUS MOVEMENT.
				if (virus.infected == null) {
					// WASD movement.
					var move:Vector2 = new Vector2(virusDirection.x * Virus.F_MOVE, virusDirection.y * Virus.F_MOVE);
					if (virusDirection.dot(virus.v) > 0) {
						move.scale((Virus.MAX_SPEED - virusSpeed)/Virus.MAX_SPEED);
					}
								
					if (input.isUpPressed) {
						virus.F.x += move.x;
						virus.F.y += move.y;
					} 
					if (input.isDownPressed) {
						virus.F.x -= move.x;
						virus.F.y -= move.y;
					}
					if (input.isLeftPressed) {
						virus.F.x += move.y;
						virus.F.y -= move.x;
					}
					if (input.isRightPressed) {
						virus.F.x -= move.y;
						virus.F.y += move.x;
					}
				} else {
					// Launch by applying an impulse.
					if (input.isSpacePressed && !input.wasSpacePressed) {
						expireLaunch();
						
						virus.v.acc(virusDirection, Virus.MAX_SPEED);
					}
				}
				
				input.wasSpacePressed = input.isSpacePressed;
				
				// WBC ATTRACTION.
				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					if (b is WBC) {
						b.graphics.clear();
						
						var wc:Vector2 = (b as IBoundingSphere).getCenter();
						
						var range:Number = (b as WBC).range;
						var v:Vector2 = virusCenter.subtract(wc);
						var lengthV:Number = v.length();
						
						b.graphics.lineStyle(1, 0x9a8685);
						b.graphics.drawCircle(b.width/2, b.height/2, range);
						
						// If virus is within range, then start "hunting" it.
						if (lengthV < range && virus.infected == null) {
							v.normalize();
							b.F.acc(v, WBC.ATTRACTION_FORCE);
							
							b.graphics.lineStyle();
							b.graphics.beginFill(0xff0000, 1.0);
							b.graphics.drawCircle(
								b.width/2 + v.x * b.width/1.5, 
								b.height/2 + v.y * b.height/1.5, 
								(range - lengthV)/range * 10
								);
						}
						
						if (b.v.length() > WBC.MAX_SPEED) {
							b.v.normalize(WBC.MAX_SPEED);
						}
					}
				}
				
				// DRAG.
				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.F.x -= b.v.x * F_DRAG;
					b.F.y -= b.v.y * F_DRAG;
				}
				
				// COLLISION PENALTY FORCES.
				var buffer:Number = 1;
				var k:Number = 10.0;

				i = 0;
				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext(); i++) {
					bi = I.next().data as Body;
					
					for (J = new LinkedListIterator(currentLevel.bodies, i+1); J.hasNext();) {
						nj = J.next();
						bj = nj.data as Body;
						
						var p:Vector2 = (bi as IBoundingSphere).getCenter();
						var r:Number  = (bi as IBoundingSphere).getRadius() + buffer;
						var q:Vector2 = (bj as IBoundingSphere).getCenter();
						var s:Number  = (bj as IBoundingSphere).getRadius() + buffer;
						
						var normal:Vector2 = Geometry.intersect(p, r, q, s);
						if (normal != null) {
							if (bi == virus) {
								if (virus.infected != null) {
									break;
								}
								
								if (bj is WBC) {
									endGame(false);
									break;
								}
								
								if (bj is RBC && normal.dot(virusDirection) > Geometry.COS_30 && virus.dna == (bj as RBC).color) {
									soundManager.playRandomInfect();
									
									virus.infected = nj;
									bj.alpha = 0.5;
									
									virus.F.zero();
									virus.v.zero();
									virus.changeDNA((bj as RBC).dna);
									virus.toggleArrow(true);

									launchTimer.start();
									
									break;
								}
							}
							
							var d:Number = normal.length();
							
							normal.normalize();
							var relativeV:Vector2 = bi.v.subtract(bj.v);
							
							// If collided bodies are already separating, don't apply force.
							if (relativeV.dot(normal) < 0) {
								continue;
							}
							
							bi.F.acc(normal, -k * d);
							bj.F.acc(normal,  k * d);
						}
					}
				}
				
				/////////////////////////////////////////
				// UPDATE
				/////////////////////////////////////////
				
				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.applyF();
					
					b.step(DT);
				}
				
				// If infecting, move virus to infected body center.
				if (virus.infected != null) {
					var pv:Vector2 = (virus as IBoundingSphere).getCenter();
					var pi:Vector2 = (virus.infected.data as IBoundingSphere).getCenter();
					
					virus.x += pi.x - pv.x;
					virus.y += pi.y - pv.y;
				}
				
				if (virusSpeed > Virus.MAX_SPEED) {
					virus.v.normalize(Virus.MAX_SPEED);
				}
				
				/////////////////////////////////////////
				// CONFINE TO BOUNDS
				/////////////////////////////////////////
				
				for (I = new LinkedListIterator(currentLevel.bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					var center:Vector2 = (b as IBoundingSphere).getCenter();
					var radius:Number = (b as IBoundingSphere).getRadius();
					
					if (center.x < radius) {
						b.x += radius - center.x;
						b.v.x *= -RESTITUTION;
					}
					
					if (center.x > main.width - radius) {
						b.x -= center.x - (main.width - radius);
						b.v.x *= -RESTITUTION;
					}
					
					if (center.y < radius) {
						b.y += radius - center.y;
						b.v.y *= -RESTITUTION;
					} 
					
					// Make sure virus does not go off bottom of viewable screen,
					// for other bodies just confine to level bounds.
					var maxHeight:Number = (b == virus) ? height - main.y : main.height;
					if (center.y > maxHeight - radius) {
						b.y -= center.y - (maxHeight - radius);
						b.v.y *= -RESTITUTION;
					}
				}
				
				/////////////////////////////////////////
				// SCROLL SCREEN
				/////////////////////////////////////////
				
				// Scroll screen according to virus position.
				virusCenter = virus.getCenter();
				if (main.y < 0 && (virusCenter.y + main.y) < height/2) {
					main.y = Math.min(0, height/2 - virusCenter.y);
				}
				
				/////////////////////////////////////////
				// TUTORIALS & EVENT TRIGGERS
				/////////////////////////////////////////
				
				currentLevel.triggerEvents(virus, main);
			}
		]]>
	</mx:Script>
	
  <!--
  /////////////////////////////////////////////////////////
  // COMPONENTS
  /////////////////////////////////////////////////////////
  -->  
  <mx:Label id="fps" />
  
  <!--- The active playing screen. -->
  <ui:TilingCanvas id="main"
  	x="200"
  	width="{LEVEL_WIDTH}" height="{height}"
  	horizontalScrollPolicy="off" verticalScrollPolicy="off" />
  
  <mx:Image id="background"
  	visible="false"
  	source="@Embed(source='assets/background.jpg')" />
	
  <!--
  /////////////////////////////////////////////////////////
  // DECLARATIONS
  /////////////////////////////////////////////////////////
  -->
	<!--- Effect for fading out destroyed bodies. -->
	<mx:Fade id="fade" alphaTo="0.0" easingFunction="{Cubic.easeIn}" />
	
	<mx:NumberFormatter id="numberFormatter" precision="2" />
	
  <!--
  /////////////////////////////////////////////////////////
  // STATES
  /////////////////////////////////////////////////////////
  -->
  <mx:states>
  	<mx:State name="splash">
  		<mx:RemoveChild target="{main}" />
  		
  		<mx:AddChild>
  			<mx:Panel 
  				x="250" y="50"
  				width="300" height="480"
  				horizontalAlign="center" 
  				horizontalScrollPolicy="off" verticalScrollPolicy="off"
  				layout="vertical"
  				cornerRadius="0">
  				
  				<mx:Image source="@Embed(source='assets/logo.png')" />
  				
  				<mx:Text width="100%" 
  					fontSize="9" textAlign="center" fontAntiAliasType="normal" fontSharpness="400"
  					paddingTop="10" paddingBottom="15" 
  					selectable="false">
  					<mx:htmlText>
	  					<![CDATA[<i>Symptom</i> is a 2D scroller with a twist. You're the virus!<br /><br />Use your <b>MOUSE</b> to guide the virus and the <b>WASD</b> keys to move. Infect a cell by moving forward towards it - once inside, "launch" away by pressing the <b>SPACE</b> bar!]]>
  					</mx:htmlText>
  				</mx:Text>
  				
  				<mx:Image source="@Embed(source='assets/directions.png')" />
  				
  				<mx:Spacer height="10" />
  				
	  			<mx:Button label="Play!" 
	  				width="100%" height="50" 
	  				click="play();" />
	  			<mx:Button label="Load custom level"
	  				width="100%" height="30"
	  				mouseDownEffect="{soundManager.buttonEffect}"
	  				click="file.browse([new FileFilter('Symptom Level', '*.xml')]);" />
	  			<mx:Button label="Create your own level!" 
	  				width="100%" height="30"
	  				mouseDownEffect="{soundManager.buttonEffect}"
	  				click="moduleInfo.load();" />
  			</mx:Panel>
  		</mx:AddChild>
  	</mx:State>
  </mx:states>
	
</mx:Application>