<?xml version="1.0" encoding="utf-8"?>
<mx:Application 
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:core="core.*"
	layout="absolute"
  width="800"
  height="600"
  backgroundColor="0x9a8685"
	backgroundGradientAlphas="{[0.0, 0.0]}"
  verticalScrollPolicy="off"
  frameRate="30"
  applicationComplete="init();">

	<mx:Style>
		Alert, Panel, TitleWindow {
			cornerRadius: 0;
			
			backgroundColor: white;
			backgroundAlpha: 0.7;
			
			borderColor: white;
			borderAlpha: 0.7;
			
			color: black;
			
			titleStyleName: "title";
		}
		
		TitleWindow {
	   closeButtonUpSkin:       Embed(source="assets/close_up.swf");
	   closeButtonDisabledSkin: Embed(source="assets/close_up.swf");
	   closeButtonOverSkin:     Embed(source="assets/close_over.swf");
	   closeButtonDownSkin:     Embed(source="assets/close_down.swf");
		}
		
		Button {
			cornerRadius: 0;
			
			themeColor: #8b6e6e;
			
			borderColor: white;
			
			fillColors: #ccaaaa, #ccaaaa;
			fillAlphas: 1.0, 1.0;
			highlightAlphas: 0.0, 0.0;
			focusAlpha: 0.0;
			
			letterSpacing: 1;
			fontSize: 9;
			fontWeight: normal;
			fontAntiAliasType: normal;
			fontSharpness: 400;
		}
		
		ScrollBar {
			highlightAlphas: 0.0, 0.0;
			trackColors: #997777, #997777;
		}
		
		Text, Label, .title {
			fontSize: 9;
			fontWeight: normal;
			fontAntiAliasType: normal;
			fontSharpness: 400;
		}
		
		.title {
			fontSize: 11;
			letterSpacing: 1;
		}
	</mx:Style>
	
	<mx:Script>
		<![CDATA[
			import core.*;
			import units.*;
			import utils.LinkedList.*;
			import utils.Vector2;
			import utils.Constants;
			import utils.FPS;
			import __AS3__.vec.Vector;
			import mx.controls.Image;
			import mx.controls.Text;
			import mx.controls.Alert;
			import mx.controls.ProgressBar;
			import mx.containers.Canvas;
			import mx.modules.ModuleManager;
			import mx.managers.PopUpManager;
			import mx.events.ModuleEvent;
			import mx.events.CloseEvent;
			import mx.modules.IModuleInfo;
			import mx.effects.Fade;
			import mx.effects.easing.Cubic;
			
			/////////////////////////////////////////////////////////////////////////
			// CONSTANTS
			/////////////////////////////////////////////////////////////////////////
			
			public static const LEVEL_WIDTH:Number = 400;
			
			public static const MIN_LEVEL_HEIGHT:Number = 600;
			public static const MAX_LEVEL_HEIGHT:Number = 6000;
			
			public static const TICKS_PER_SECOND:int = 30;
			public static const DT:Number = 1.0 / TICKS_PER_SECOND;
			
			public static const LAUNCH_TIME_MS:Number = 2000.0;
			
			public static const F_DRAG:Number = 0.01;
			public static const MAX_COLLISION_ITERATIONS:int = 2;
			public static const RESTITUTION:Number = 0.3;
			
			public static const VICTORY_DISTANCE:Number = 20.0;
			
			/////////////////////////////////////////////////////////////////////////
			// VARIABLES
			/////////////////////////////////////////////////////////////////////////
			
			/** For loading modules. */
			protected var moduleInfo:IModuleInfo;

			/** For uploading files. */
			protected var file:FileReference;
			
			/** The level editor. */
			protected var levelEditor:LevelEditor;
			
			/** Timer for the game loop. */
			protected var loopTimer:Timer;
			/** Timer for virus launch. */
			protected var launchTimer:Timer;
			
			/** All collidable bodies in a level. */
			protected var bodies:LinkedList;
			/** End areas in a level. */
			protected var endAreas:Vector.<EndArea>;
			
			/** The player-controlled virus. */
			protected var virus:Virus;
			/** The list node of the current virus-infected Body object, if any. */
			protected var infected:Node;
			
			/** Is the up key currently pressed? */
			protected var isUpPressed:Boolean     = false;
			/** Is the down key currently pressed? */
			protected var isDownPressed:Boolean   = false;
			/** Is the left key currently pressed? */
			protected var isLeftPressed:Boolean   = false;
			/** Is the right key currently pressed? */
			protected var isRightPressed:Boolean  = false;
			
			/** Is the space bar currently pressed? */
			protected var isSpacePressed:Boolean  = false;
			/** Was the space bar pressed last frame? */
			protected var wasSpacePressed:Boolean = false;

			protected function init():void {
				currentState = "splash";
				
				// Set up level loading mechanism.
				file = new FileReference();
				file.addEventListener(Event.SELECT, function():void { file.load(); });
				file.addEventListener(Event.COMPLETE, loadLevel);

				main.setTileImage(background);
			}
			
			/** Starts a new game to play. */
			protected function play(customLevel:XML = null):void {
				currentState = "";
				
				main.removeAllChildren();
				
				bodies = new LinkedList();
				endAreas = new Vector.<EndArea>();
				
				virus = new Virus(this);
				bodies.push(virus);
				
				if (customLevel == null) {
					// TODO Load predefined levels!
				} else {
					// Load custom level.
					try {
						main.height = Number(customLevel.@height);
					} catch (e:Error) {
						Alert.show("Invalid map height.", "Symptom > Load custom level");
					}
					main.height = Math.max(MIN_LEVEL_HEIGHT, Math.min(MAX_LEVEL_HEIGHT, main.height));
					main.y = height - main.height;
					
					var xml:XML;
					
					for each (xml in customLevel.EndArea) {
						var end:EndArea = new EndArea();
						end.x = xml.x;
						end.y = xml.y;
						
						endAreas.push(end);
						main.addChild(end);
					}
					
					for each (xml in customLevel.RBC) {
						var rbc:RBC = new RBC();
						rbc.setColors(Color.fromString(xml.color), Color.fromString(xml.dna));
						rbc.rotation = Math.random() * 360;
						
						var center:Vector2 = rbc.getCenter();
						rbc.x = xml.x - center.x;
						rbc.y = xml.y - center.y;
						
						bodies.push(rbc);
						main.addChild(rbc);
					}
					
					for each (xml in customLevel.WBC) {
						var wbc:WBC = new WBC();
						wbc.x = xml.x;
						wbc.y = xml.y;
						
						bodies.push(wbc);
						main.addChild(wbc);
					}
				}

				virus.x = main.width/2 - virus.width/2;
				virus.y = main.height - virus.height - 5;
				main.addChild(virus);

				// Set up timers.
				loopTimer = new Timer(1000 / TICKS_PER_SECOND);
				loopTimer.addEventListener(TimerEvent.TIMER, theLoop);

				var launchDelay:Number = 20;
				launchTimer = new Timer(launchDelay, LAUNCH_TIME_MS / launchDelay);
				launchTimer.addEventListener(TimerEvent.TIMER, expireLaunch);
				
				// Keyboard events.
				stage.addEventListener(KeyboardEvent.KEY_DOWN, keyListener);
				stage.addEventListener(KeyboardEvent.KEY_UP, keyListener);
				
				loopTimer.start();
			}
			
			/** Opens the level editor module as a pop-up. */
			protected function openLevelEditor():void {
				moduleInfo = ModuleManager.getModule("LevelEditor.swf");
				moduleInfo.addEventListener(ModuleEvent.READY, _openLevelEditor);
				moduleInfo.load();
			}
			
			// Listener for loadEditor().
			private function _openLevelEditor(e:ModuleEvent):void {
				levelEditor = moduleInfo.factory.create() as LevelEditor;
				
				PopUpManager.addPopUp(levelEditor, this, false);
				PopUpManager.centerPopUp(levelEditor);
			}
			
			// Loads level data from a pre-selected file. Should not be called directly.
			private function loadLevel(e:Event):void {
				var data:ByteArray = file.data;
				
				try {
					var level:XML = XML(data.readUTFBytes(data.bytesAvailable));
				} catch (e:Error) {
					Alert.show("Selected file has invalid content!", "Symptom > Load custom level");
					return;
				}
				
				play(level);
			}
			
			/** Keyboard event listener. */
			protected function keyListener(e:KeyboardEvent):void {
				var isKeyDown:Boolean = (e.type == KeyboardEvent.KEY_DOWN);
				
				if (e.keyCode == 87) { // W
					isUpPressed = isKeyDown;
				} else if (e.keyCode == 83) { // S
					isDownPressed = isKeyDown;
				} else if (e.keyCode == 65) { // A
					isLeftPressed = isKeyDown;
				} else if (e.keyCode == 68) { // D
					isRightPressed = isKeyDown;
				} else if (e.keyCode == Keyboard.SPACE) {
					isSpacePressed = isKeyDown;
				}
			}
			
			/** Ends the game. */
			protected function endGame(isWin:Boolean):void {
				loopTimer.stop();
				launchTimer.stop();

				if (isWin) {						
					Alert.show(
						"You win!", 
						"Symptom", 
						Alert.OK, 
						this, 
						function(e:CloseEvent):void { currentState = "splash"; }
						);
				} else {
					Alert.show(
						"You lost!", 
						"Symptom", 
						Alert.OK, 
						this, 
						function(e:CloseEvent):void { currentState = "splash"; }
						);
				}
			}

			/** Checks launch timer expiration and handles launching. */
			protected function expireLaunch(e:TimerEvent = null):void {
				if (e != null) {
					// Draw launch progress indicator ring.
					var r:Number = 8;
					var a:Number = 1.0 - (launchTimer.currentCount / launchTimer.repeatCount);
					
					virus.graphics.clear();
					virus.graphics.beginFill(0x00aa00);
					virus.graphics.drawCircle(virus.width/2, -r, r*a);
					
					if (launchTimer.currentCount < launchTimer.repeatCount) {
						return;
					}
				}
				
				virus.graphics.clear();
				virus.toggleArrow(false);
				
				launchTimer.reset();
				
				var i:Body = infected.data as Body;
				bodies.pop(infected);
				i.setStyle("removedEffect", fade);
				main.removeChild(i);
				
				infected = null;
			}
			
			/** The main game loop. */
			protected function theLoop(e:TimerEvent):void {
				var i:int, j:int;
				var b:Body, bi:Body, bj:Body;
				var img:Image;
				var I:LinkedListIterator, J:LinkedListIterator;
				var ni:Node, nj:Node;
				var f:EndArea;
				
				var virusCenter:Vector2    = virus.getCenter();
				var virusDirection:Vector2 = virus.getDirection();
				var virusSpeed:Number      = virus.v.length();
				
				/////////////////////////////////////////
				// CHECK FOR VICTORY CONDITION
				/////////////////////////////////////////
				
				for each (f in endAreas) {						
					var fc:Vector2 = new Vector2(f.x + f.width/2, f.y + f.height/2);
					
					if (virusCenter.subtract(fc).length() < VICTORY_DISTANCE) {
						endGame(true);
					}
				}
				
				/////////////////////////////////////////
				// CLEAR FORCES
				/////////////////////////////////////////

				for (I = new LinkedListIterator(bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.F.reset();
				}
				
				/////////////////////////////////////////
				// ADD FORCES
				/////////////////////////////////////////
				
				// VIRUS MOVEMENT.
				if (infected == null) {
					// WASD movement.
					var m:Vector2 = new Vector2(virusDirection.x * Virus.F_MOVE, virusDirection.y * Virus.F_MOVE);
					if (virusDirection.dot(virus.v) > 0) {
						m.scale((Virus.MAX_SPEED - virusSpeed)/Virus.MAX_SPEED);
					}
								
					if (isUpPressed) {
						virus.F.x += m.x;
						virus.F.y += m.y;
					} 
					if (isDownPressed) {
						virus.F.x -= m.x;
						virus.F.y -= m.y;
					}
					if (isLeftPressed) {
						virus.F.x += m.y;
						virus.F.y -= m.x;
					}
					if (isRightPressed) {
						virus.F.x -= m.y;
						virus.F.y += m.x;
					}
				} else {
					// Launch by applying an impulse.
					if (isSpacePressed && !wasSpacePressed) {
						expireLaunch();
						
						virus.v.acc(virusDirection, Virus.MAX_SPEED);
					}
				}
				
				wasSpacePressed = isSpacePressed;
				
				// WBC ATTRACTION.
				for (I = new LinkedListIterator(bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					if (b is WBC) {
						b.graphics.clear();
						
						var wc:Vector2 = (b as IBoundingSphere).getCenter();
						
						var range:Number = (b as WBC).range;
						var v:Vector2 = virusCenter.subtract(wc);
						var lengthV:Number = v.length();
						
						if (lengthV < range && infected == null) {
							v.normalize();
							b.F.acc(v, WBC.ATTRACTION_FORCE);
							
							b.graphics.beginFill(0xff0000, 1.0);
							b.graphics.drawCircle(
								b.width/2 + v.x * b.width/1.5, 
								b.height/2 + v.y * b.height/1.5, 
								(range - lengthV)/range * 10
								);
						}
						
						if (b.v.length() > WBC.MAX_SPEED) {
							b.v.normalize(WBC.MAX_SPEED);
						}
					}
				}
				
				// DRAG.
				for (I = new LinkedListIterator(bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.F.x -= b.v.x * F_DRAG;
					b.F.y -= b.v.y * F_DRAG;
				}
				
				// COLLISION PENALTY FORCES.
				var buffer:Number = 1;
				var k:Number = 10.0;

				i = 0;
				for (I = new LinkedListIterator(bodies); I.hasNext(); i++) {
					bi = I.next().data as Body;;
					
					for (J = new LinkedListIterator(bodies, i+1); J.hasNext();) {
						nj = J.next();
						bj = nj.data as Body;
						
						var p:Vector2 = (bi as IBoundingSphere).getCenter();
						var r:Number  = (bi as IBoundingSphere).getRadius() + buffer;
						var q:Vector2 = (bj as IBoundingSphere).getCenter();
						var s:Number  = (bj as IBoundingSphere).getRadius() + buffer;
						
						var normal:Vector2 = intersect(p, r, q, s);
							
						if (normal != null) {

							if (bi == virus) {
								if (infected != null) {
									break;
								}
								
								if (bj is WBC) {
									endGame(false);
									break;
								}
								
								if (bj is RBC && normal.dot(virusDirection) > Constants.COS_30 && virus.dna == (bj as RBC).color) {
									infected = nj;
									bj.alpha = 0.5;
									
									virus.F.reset();
									virus.v.reset();
									virus.changeDNA((bj as RBC).dna);
									virus.toggleArrow(true);

									launchTimer.start();
									
									break;
								}
							}
							
							var d:Number = normal.length();
							normal.normalize();
							var relativeV:Vector2 = bi.v.subtract(bj.v);
							var dot:Number = relativeV.dot(normal);
							
							if (dot < 0) {
								continue;
							}
							
							bi.F.acc(normal, -k * d);
							bj.F.acc(normal,  k * d);
						}
					}
				}
				
				/////////////////////////////////////////
				// UPDATE
				/////////////////////////////////////////
				
				for (I = new LinkedListIterator(bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					b.applyF();
					
					b.step(DT);
					
					// Scroll screen according to virus movement & position.
					if (b == virus && main.y < 0 && b.y + main.y < height/3 && b.v.y < 0) {
						main.y = Math.min(0, main.y - b.v.y * DT);
					}
				}
				
				// If infecting, move virus to infected body center.
				if (infected != null) {
					var pv:Vector2 = (virus as IBoundingSphere).getCenter();
					var pi:Vector2 = (infected.data as IBoundingSphere).getCenter();
					
					virus.x += pi.x - pv.x;
					virus.y += pi.y - pv.y;
				}
				
				if (virusSpeed > Virus.MAX_SPEED) {
					virus.v.normalize(Virus.MAX_SPEED);
				}
				
				/////////////////////////////////////////
				// CONFINE TO BOUNDS
				/////////////////////////////////////////
				
				for (I = new LinkedListIterator(bodies); I.hasNext();) {
					b = I.next().data as Body;
					
					var center:Vector2 = (b as IBoundingSphere).getCenter();
					var radius:Number = (b as IBoundingSphere).getRadius();
					
					if (center.x < radius) {
						b.x += radius - center.x;
						b.v.x *= -RESTITUTION;
					}
					
					if (center.x > main.width - radius) {
						b.x -= center.x - (main.width - radius);
						b.v.x *= -RESTITUTION;
					}
					
					if (center.y < radius) {
						b.y += radius - center.y;
						b.v.y *= -RESTITUTION;
					} 
					
					// Make sure virus does not go off bottom of viewable screen,
					// for other bodies just confine to level bounds.
					var maxHeight:Number = (b == virus) ? height - main.y : main.height;
					if (center.y > maxHeight - radius) {
						b.y -= center.y - (maxHeight - radius);
						b.v.y *= -RESTITUTION;
					}
				}
			}
			
			/**
			 * Tests intersection of two spheres.
			 * 
			 * @param centerA Center point of first sphere.
			 * @param radiusA Radius of first sphere.
			 * @param centerB Center point of second sphere.
			 * @param radiusB Radius of second sphere.
			 * 
			 * @return If spheres intersect, return the contact normal scaled by penetration distance. Otherwise, return null.
			 */
			public static function intersect(centerA:Vector2, radiusA:Number, centerB:Vector2, radiusB:Number):Vector2 {				
				var d:Vector2 = centerB.subtract(centerA);
				
				var l:Number = d.length();
				if (l < radiusA + radiusB) {
					d.normalize(radiusA + radiusB - l);
					return d;
				}
				
				return null;
			}
		]]>
	</mx:Script>
	
  <!--
  /////////////////////////////////////////////////////////
  // COMPONENTS
  /////////////////////////////////////////////////////////
  -->  
  <!--- The active playing screen. -->
  <core:TilingCanvas id="main"
  	x="200"
  	width="{LEVEL_WIDTH}" height="{height}"
  	horizontalScrollPolicy="off" verticalScrollPolicy="off" />
  
  <mx:Image id="background"
  	visible="false"
  	source="@Embed(source='assets/background.jpg')" />
	
  <!--
  /////////////////////////////////////////////////////////
  // DECLARATIONS
  /////////////////////////////////////////////////////////
  -->
	<!--- Effect for fading out destroyed bodies. -->
	<mx:Fade id="fade" alphaTo="0.0" easingFunction="{Cubic.easeIn}" />
	
	<mx:NumberFormatter id="numberFormatter" precision="2" />
	
  <!--
  /////////////////////////////////////////////////////////
  // STATES
  /////////////////////////////////////////////////////////
  -->
  <mx:states>
  	<mx:State name="splash">
  		<mx:RemoveChild target="{main}" />
  		
  		<mx:AddChild>
  			<mx:Panel 
  				x="250" y="50"
  				width="300" height="480"
  				horizontalAlign="center" 
  				horizontalScrollPolicy="off" verticalScrollPolicy="off"
  				layout="vertical"
  				cornerRadius="0">
  				
  				<mx:Image source="@Embed(source='assets/logo.png')" />
  				
  				<mx:Text width="100%" 
  					fontSize="9" textAlign="center" fontAntiAliasType="normal" fontSharpness="400"
  					paddingTop="10" paddingBottom="15" 
  					selectable="false">
  					<mx:htmlText>
	  					<![CDATA[<i>Symptom</i> is a 2D scroller with a twist. You're the virus!<br /><br />Use your <b>MOUSE</b> to guide the virus and the <b>WASD</b> keys to move. Infect a cell by moving forward towards it - once inside, "launch" away by pressing the <b>SPACE</b> bar!]]>
  					</mx:htmlText>
  				</mx:Text>
  				
  				<mx:Image source="@Embed(source='assets/directions.png')" />
  				
  				<mx:Spacer height="10" />
  				
	  			<mx:Button label="Play!" 
	  				width="100%" height="50" 
	  				enabled="false"
	  				click="play();" />
	  			<mx:Button label="Load custom level"
	  				width="100%" height="30"
	  				click="file.browse([new FileFilter('Symptom Level', '*.xml')]);" />
	  			<mx:Button label="Create your own level!" 
	  				width="100%" height="30"
	  				click="openLevelEditor();" />
  			</mx:Panel>
  		</mx:AddChild>
  	</mx:State>
  </mx:states>
	
</mx:Application>